pico-8 cartridge // http://www.pico-8.com
version 35
__lua__
-- main

map_width=16
map_height=16
m={}

function _init()
    --player init
	p=make_player(3,3)
	cam=make_camera()

    --enemies init
    zombies={}

    --map init
    m=make_map()

    frict=0.9
end

function _draw()

    cls()
	
	map(0,0)
	
	--player
    p:draw()

    --map
    print_map(m)
    cam:draw()

    --zombie
	for zombie in all(zombies) do
		zombie:draw()
        enemy_collide(p, zombie)
	end

    --debug
	print(p.x,p.x*8-62,p.y*8-62,8)
	print(p.y,p.x*8-62,p.y*8-56,8)
	print(p.dx,p.x*8-62,p.y*8-50,8)
	print(p.dy,p.x*8-62,p.y*8-44,8)
end

function _update()
    p:control()
    p:update()
    
    -- map
    m=make_map()
    distmap()

    cam:update(p.x, p.y)

    --zombie
	for zombie in all(zombies) do
		zombie:control(p)
		zombie:update(p)
	end
end
-->8
-- player and zombies

function make_player(x, y)
    -- everything is in a table
    -- units are in tiles, where each tile is 8x8 pixels
    pl={
        -- fields
        sp=1,
        x=x,
        y=y,
        w=0.45,
        h=0.45,
        dx=0,
        dy=0,
        max_dx=0.5,
        max_dy=0.5,
        accel=0.1,

        -- functions
        control=function(self)
            if btn(⬅️) then
                self.dx-=self.accel
            end
            if btn(➡️) then
                self.dx+=self.accel
            end
            if btn(⬆️) then
                self.dy-=self.accel
            end
            if btn(⬇️) then
                self.dy+=self.accel
            end

            -- ensures player doesnt exceed max dx or dy in any direction
            self.dx=mid(-self.max_dx, self.dx, self.max_dx)
			self.dy=mid(-self.max_dy, self.dy, self.max_dy)
        end,

        draw=function(self)
            spr(self.sp,(self.x*8)-4,(self.y*8)-4)
        end,

        update=function(self)
            -- wall collide
            if not solid_area(self.x+self.dx,self.y,self.w,self.h) then
                self.x+=self.dx
            else
                self.dx*=-0.5
                self.x+=self.dx
            end
					
            if not solid_area(self.x,self.y+self.dy,self.w,self.h) then
                self.y+=self.dy
            else
                self.dy=0
                self.y+=self.dy
            end

            self.dx*=frict
			self.dy*=frict
        end
    }

    return pl
end

function make_zombie(x, y)
    add(zombies,{
		sp=4,
		x=x,
		y=y,
		w=0.45,
		h=0.45,
		dx=0,
		dy=0,
		max_dx=0.1,
		max_dy=0.1,
		accel=0.1,
		
		control=function(self,a)
			if self.x > a.x+0.5 then
				self.dx-=self.accel
			elseif self.x < a.x-0.5 then
				self.dx+=self.accel
			else
				self.dx=0
			end
				
			if self.y > a.y+0.5 then
				self.dy-=self.accel
			elseif self.y < a.y-0.5 then
				self.dy+=self.accel
			else
				self.dy=0
			end
			
			self.dx=mid(-self.max_dx,self.dx,self.max_dx)
			self.dy=mid(-self.max_dy,self.dy,self.max_dy)
		end,
		
		update=function(self,a)
		    --map collide	
			if not solid_area(self.x+self.dx,self.y,self.w,self.h) then
				self.x+=self.dx
			else
				self.dx=0
			end
			
			if not solid_area(self.x,self.y+self.dy,self.w,self.h) then
				self.y+=self.dy
			else		
				self.dy=0
			end
		end,
		
		draw=function(self)
			spr(self.sp,(self.x*8)-4,(self.y*8)-4)
		end
		})
end

function make_camera()
	cam={
		cx=0,
		cy=0,
		
		update=function(self,x,y)
			self.cx=x*8-62
			self.cy=y*8-62
		end,
		
		draw=function(self)
			camera(self.cx,self.cy)
		end
		}
		
	return cam
end

-->8
-- map
key_direction = {
  [0] = {x = -1, y = 0},
  [1] = {x = 1, y = 0},
  [2] = {x = 0, y = -1},
  [3] = {x = 0, y = 1}
}

function make_map()
    m={}
    for j=0, map_height do
        -- adding new row
        m[j]={}
        for i=0, map_width do
            if solid(i, j) then
                m[j][i]=99
            else
                m[j][i]=0
            end
        end
    end
    return m
end

-- for debug
function print_map(m)
    for j=0, map_height do
        -- adding new row
        for i=0, map_width do
            print(m[j][i],i*8,j*8,2)
        end
    end
end

function distmap()
    local queue = {}
    local toAdd = {}
    
    -- adding the players x, y to the queue
    add(queue, {
        x = flr(p.x),
        y = flr(p.y)
    })

   toAdd = goQueue(queue)

   while #toAdd > 0 do
        toAdd = goQueue(toAdd)
   end 

   m[flr(p.y)][flr(p.x)] = 0
end

function goQueue(queue)
     local toAdd = {}

    for t in all(queue) do
        -- note the distance of the current tile
        local curr_tile_dist = m[t.y][t.x]

        for i=0, 3 do
            -- check adjacent tiles in the cardinal directions
            local d = key_direction[i]
            
            -- True "position" of tile in m[x][y] looking in every direction
            local ax = t.x + d.x    -- d.x looks left or right
            local ay = t.y + d.y    -- d.y looks up or down

            -- if the adjacent tile is passable and hasn't yet been traversed (i.e. distance is 9999)
            if not solid(ax, ay) and m[ay][ax] == 0 then
                -- set the distance of the adjacent tile to the current tile's distance + 1
                m[ay][ax] = curr_tile_dist + 1

                -- and add the adjacent tile to the frontier
                add(toAdd, {
                    x = flr(ax),
                    y = flr(ay)
                })
            end
        end

        -- after all adjacent tiles have been checked, remove the tile from the frontier
        del(queue, t) 
    end

    return toAdd
end

-->8
-- enemy collisions
function enemy_collide(p, z)
    if detect_collide(p,z) then
        print("c", p.x, p.y, 8)
    end
end

function detect_collide(p, z)
    return ((((p.x <= z.x) and (z.x <= p.x+p.w+0.5)) and (((p.y <= z.y+z.h+0.5) and (z.y+z.h+0.5 <= p.y+p.h+0.5)) or ((z.y <= p.y+p.h+0.5) and (p.y+p.h+0.5 <= z.y+z.h+0.5)))) or 
             (((z.x <= p.x) and (p.x <= z.x+z.w+0.5)) and (((p.y <= z.y+z.h+0.5) and (z.y+z.h+0.5 <= p.y+p.h+0.5)) or ((z.y <= p.y+p.h+0.5) and (p.y+p.h+0.5 <= z.y+z.h+0.5)))))
end

-- wall collision
--cr: zep tutorial
function solid(x,y)
	return fget(mget(x,y),0)
end

function solid_area(x,y,w,h)
 return 
  solid(x-w,y-h) or
  solid(x+w,y-h) or
  solid(x-w,y+h) or
  solid(x+w,y+h)
end

__gfx__
00000000888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00700700888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00077000888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00077000888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00700700888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000888888886666666655555555bbbbbbbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
__gff__
0000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
__map__
0202020202020202020202020202020202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000020202020202000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000020202020202000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0202020202020202020202020202020002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000002020202000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0200000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0202020202020202020202020202020202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
